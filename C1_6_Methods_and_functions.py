# C1.6 Методы и функции

# Мы умееи задавать структуру для наших данных с помощью атрибутов. 
# Но часто у объектов есть связанная с ними логика, которую мы хотим 
# реализовать в привязке к таким объектам - и это тоже можно 
# реализовать с помощью классов. Для этого используем методы.

# Методы - это всего лиш функция, реализованная внутри класса, и пераым
# аргументом принимающая self:

class Product:
	def __init__(self, name, category, quantity_in_stock):
		self.name = name 
		self.category = category
		self.quantity_in_stock = quantity_in_stock
		
	def is_available(self):
		return True if self.quantity_in_stock > 0 else False
		
# Здесь и __init__, и is_available - это методы. По умолчанию первым
# аргументом во все методы класса подаётся self - именно так метод
# получает доступ к экземпляру класса. Мы рассмотрим исключения позже в
# течение курса. При этом, чтобы вызвать исполнение метода, 
# передавать self уже не нужно.

eggs = Product("eggs", "food", 5)
print(eggs.is_available())
# Вывод:
# True

# Для вызова метода, как и для вызова функции, используются круглые
# скобк. Разница между методом и функции только в том, что метод 
# вызывается от конкртного обьекта и реализован внутри класса, 
# а функция работает сама по себе.

# Пусть мы хотим обрабатывать некоторые события из уже известных нам
# логов событий. Создадим класс с конструктора:

class Event:
	def __init__(self, timestamp, event_type, sessiom_id):
		self.timestamp = timestamp
		self.event_type = event_type
		self.sessiom_id = sessiom_id
		
		
# Допустим, мы уже распарсили наши логи и получили список словарей 
# вроде такого:

events = [
	{
	"timestamp": 1554583508000,
	"type": "itemViewEvent",
	"sessiom_id":
"0:NyteeXG:MYLskqZbcmXNSFEJaZIsNVGeDLLpmct",
	},
	{
	"timestamp": 1555296337000,
	"type": "itemViewEvent",
	"sessiom_id":
"0:NyteeXG:MYLskqZbcmXNSFEJaZIsNVGeDLLpmct",
	},
	{
	"timestamp": 1549461608000,
	"type": "itemBuyEvent",
	"sessiom_id":
"0:NyteeXG:MYLskqZbcmXNSFEJaZIsNVGeDLLpmct",
	},
]

# Давайте для каждого события в списке создадим соответствующий ему
# объект с помощью конструктора, как мы уже делали. А чтобы убедиться,
# что обьект создаётся, выведем на печать какой-нибудь из атрибутов:

for event in events:
	event_obj = Event(timestamp=event.get("timestamp"),
				event_type=event.get("type"),
				sessiom_id=event.get("sessiom_id"))
	print(event_obj.timestamp)

# Вывод:
# 1554583508000
# 1555296337000
# 1549461608000

# Здесь мы использовали метод словаря .get(), который возвращает 
# значение ключа и не вызывает ошибку, если такого ключа в словоре нет.

# Вместо такого явного разбора словаря в цикле мы могли бы задать нашему
# классу метод, который позволяет инициализировать наш объект
# напрямую.

# Для этого давайте поправим объявление нашего класса и зададим для
# каждой переменной её значение по умолчанию, чтобы мы могли
# инициализировать объект без заполнения. Это делается с помощью
# указания значений по умолчанию сразу после названия аргумента:

class Event:
	def __init__(self, timestamp=0, event_type="",
sessiom_id="":
		self.timestamp = timestamp
		self.type = type
		self.sessiom_id = sessiom_id
		
# Отлично, а теперь добавим метод. Не забываем, что метод принимает на
# вход self первым аргументом.

def init_from_dist(self, event_dist):
		self.timestamp = event_dist.get("timestamp")
		self.type = event_dist.get("type")
		self.sessiom_id = event_dist.get("sessiom_id")
		
# Метод и дёт с отступом и должен быть объявлен внутри класса.

# После, этого мы скрыли реализацию логики от пользователя - то есть нам
# уже не важно, как это работает, мы знаем, что может подать на вход
# словарь с нужным ключами, и всё будет работать само.

for event in events:
	event_obj = Event()
	event_obj.init_from_dist(event)
	print(event_obj.timestamp)
	
# Вывод:
# 1554583508000
# 1555296337000
# 1549461608000

# Методы облегчают работу с объектами класса, предоставляя готовую из
# удобную логику.

# Как вы уже заметели, стандартные типы данных Python также
# предоставляют готовый набор методов для работы с ними. Например,
# строки есть метод .split(), который мы уже использовали - и это
# именно метод в полноценном смысле: где-то внутри Python определён
# класс сторок и их методов.

# Важно перевести получанные знания в умение!

# Для этого мы рекомендуем воспреизвести весь код в PyCharm.


class Event:
	def __init__(self, timestamp, event_type, sessiom_id):
		self.timestamp = timestamp
		self.event_type = event_type
		self.sessiom_id = sessiom_id
events = [
	{
	"timestamp": 1554583508000,
	"type": "itemViewEvent",
	"sessiom_id":
"0:NyteeXG:MYLskqZbcmXNSFEJaZIsNVGeDLLpmct",
	},
	{
	"timestamp": 1555296337000, 
	"type": "itemViewEvent",
	"sessiom_id":
"0:NyteeXG:MYLskqZbcmXNSFEJaZIsNVGeDLLpmct",
	},
	{
	"timestamp": 1549461608000,
	"type": "itemBuyEvent",
	"sessiom_id":
"0:NyteeXG:MYLskqZbcmXNSFEJaZIsNVGeDLLpmct",
	},
]

for event in events:
	event_obj = Event()
	event_obj.init_from_dist(event)
	print(event_obj.timestamp)

# Давайте перед тем, как приступим к работе с наследованием, вернёмся 
# к уже затронутому ранее понятию - инкапсуляции.

# Инкапсуляция - это один из принципов ООП, который говорит 
# нам о том, что поля и методы должны быть одной целой 
# системой. Иначе говоря, работаем с полями класса только 
# через методы.

# С начала вспомним, как мы только работали с полями класса:

# Пример неправильного кода:

# Создаём неправильный класс:
class Human:
	# класс человек с полем возраста
	age = None
	
	def __init__(self, age=4)
		self.age = age
		
h = Human()
h.age = 15 # (Так делать лучше не стоит, если вы хотите 
			  когда-нибудь найти работу)
print(h.age) # и так тоже

# Но что же здесь неправильного, спросите вы? Сейчас мы всё разберём
# подробно на примере, и вы всё поймёте. Сначала спросите себя, а может
# ли человеку быть -20 лет? А "abcde" лет? Ну конечно же нет. Но при таком
# подходе, оставляя поля класса открытыми, вы оставляете их абсолютно 
# беззащитными перед внешним воздействием. За этим и нужна инкапсуляция.
# Она говорит нам, что мы должны беречь наши классы и обрабатывать
# каждое обращение к его полям. Сейчас вы уже увидете, что нужно
# исправить, пока ещё поздно.

# Более правильный пример:

# Исправим наш предыдущий код.
class Human:
	age = None
	
	def __init__(self, age=4)
		self.age = age
		
	# добавим геттер - специальный метод для получения поля
	def get_age(self)
		return self.age
		
	# добавим сеттер - специальный метод для установки нового значения
	def set_age(self,age):
		if age > 0 and isinstance(age, int): # проверяем условие,
							что человек должно быть больше 0 лет
							и его возвраст - целое число
			self.age = age
	
h = Human()
h.set_age(15)
print(h.get_age())
		
# Здесь мы уже контролируем обращение к полям класса. Мы добавили
# специальные методы: геттеры и сеттеры.

# Гаттеры - пишется так: get_<имя поля>. Геттер просто возвращает 
# значение поля и не принимает никаких аргументов.

# Основная задача геттера - не давать изменять атрибут класса вне класса.
# Это значит, что при использовании обычной переменной age её можно 
# будет изменять в основном коде:

h.age = 11
print(h.age)

# С геттером так не получатся. Используя геттер, вы явно указываете в коде, 
# что значение только для чтения. Вы можете получить его, но не можете
# изменить.

print(h.get_age())

# Это своеобразная защита для других разрабочиков. Используя функцию 
# get_age() нельзя случайно задать ему значение. 

# Сеттер - пишется так: set_<имя поля>. Cеттер принимает один 
# аргкмент - значение, которое он должен устанавливать в поле.

# В принципе на этом можно сказать, что с инкапсуляцией мы
# познакомились. Для начала такого понимания хватит. Мы ещё вернёмся к
# ней, когда будет изучать декораторы класса.

# Теперь у нас уже есть достаточно инструментов, чтобы почувствовать, 
# зачем нужны классы: по факту, классы - это связка между определённой 
# структурой данных, хранящихся в атрибутах, и логикой, которая
# непосредственно относиться к ним. Плюс ко всему мы познакомились с 
# нашей первой концепцией ООП - инкапсуляцией, которая говорит нам,
# что поля класса должны обрабатывать только через специальные
# методы - геттеры и сеттеры.

# 1.6.1
# Верно ли то, что метод принимает первыс аргумент self?
# 
# False
#
# True +++

# 1.6.2
# Функция называеться от конкретного обьекта, а метод работает сам по
# себе. Правда или нет?
# 
# False +++
#
# True 
 
6


	

