# С.1.7_Наследование_не_доделал.ру

# Помимо того, что классы служат фабрикой по производству однотипных
# объектов со сходным поведением, они имеют ещё одну важдую
# очобенность - наследование. 

# Как мы уже видели, объекты, созданные при помощи класса,
# наследуют атрибуты класса, которые объявлены прямо в теле, а не
# добавлены в конкретный независимый экземпляр.

# Идея наследовния класса с остоит в том, что новый класс создаётся не на
# "пустом месте", а на основе уже существуещего. В результате 
# наследования все поля и функции из базового класса неявным образом 
# "наследуются" в произвольномклассе".

# При описании производноо класса используем шаблон:

class ПроизвольныйКласс (БазовыйКласс)
	# Тело класса

# Таким образом, классы умеют наследовать друг у друга, причём не только
# атрибуты, но и методы.

# Это значит, что родительские атрибуты и методы будут доступны у так 
# называемых дочерних(или производных) классов. Убедимся в это. Чтобы
# задать родительский класс, надо указать кго в скобках при объявлении 
# производного класса, как будто это пргумент функции:

import datetime

class Product:
	max_quantity = 100000

	def _init_(self, name, category, quantity_in_stock):
		self.name = name
		self.category = category
		self.quantity_in_stock = quantity_in_stock

	def is_available(self)
		return True if self.quantity_in_stock > 0 else False

class Food(Product):
	is_critical = True
	needs_to_be_refreshed = True
	refresh_frequencty = datetime.timedelta(days=1)

eggs = Food(name="eggs", category="food",
quantity_in_stock = 5)
print(eggs.max_quantity)

# Вывод:
# 10000
# print(eggs.max_quantity)

# Вывод:
# True 

# Мы видим, что мы создавали объект eggs как экземпляр класса Food, но 
# при этом ему доступны как атрибуты родительского класса (max_quantity), 
# так и его методы (is_available).

# Фактически произошло ещё более интересное: для создания экземпляра
# класса Food мы используем конструктор его родительского класса
# Product.

# Прежде чем пойти дальше, давайте изучем одну полезную конструкцию: if
# _name_ == "_main_:

# Данная конструкция позволяет запускать код блока if в
# зависимости от запущенного файла. В переменной _name_ мы храним
# путь, откуда хапущен файл.

# Если мы запустили файл из консоли: python *имя файла*, то в 
# переменной _name_ будет строка "_main_". Если мы импортировали
# файл из другого файла, в переменной _name_ будет просто название
# самого файла.

# Таким образом, блок кода, который идёт после условия if _name_ == 
# "_main_":, будет выполняться, если мы запустили файл из консоли и
# не будет, если мы экспортируем этот файл.

# Пока не очень понятно? Давайте разберём на примере и создадим два 
# файла: myclass.py и main.py.

# в файле myclass.py опишем небольшой класс, а также используем
# предложенную конструкцию:

clfss MyClass():
	def f(self):
		return 155

if _name_ == "_main_":
	mc=MyClass()
	print("It's only for tedt", mc.f())

# Запустим файл myclass.py:

It's only for test 155

# Теперь немного модернизируем код для наглядности:

class MyClass():
	def f(self):
		return 155
mc2+MyClass()
print("It's for test too", mc.f())

if _name_ == "_main_":
	mc=MyClass()
	print("It's only for test:, mc.f())

# Запустим файл meclass.py:

It's for tedt too 155
It's only for test 155

# Так как мы запускаем файл myclass.py, то оба вывода работают. 

# А теперь создадим ситуацию, когда один из них работать не будет. В файл 
# main.pу добавим следующий фрагмент кода:

from myclass import MyClass
if _name_ == "_main_":
	m=MyClass()
	print("It's really working:",m.f())

# Запустим файл main.py:

It's for test too 155
It's really working: 155

# Мы видим, что часть кода, которая не была записана в условие, 
# исполняется при запуске в файл main.py.

# Подведём итог: код в конструкции if _name_ == "_main_": будет
# выполняться только при запуске файла, в котором он находится. Это очень
# удобно, когда вы хтите протестировать классы в отдельных файлах или 
# переиспользоваться код одного из файлов, не удаляя из него вызовы
# функции и объявления классов. 

# Вернёмся к наследию.

# Важно, если мы назовём атрибут или метод так же, как он называется в
# родительском классе, он будет переопределён. Рассмотрим на примере:

class Event:
	def _init_(self, timestamp = 0, event_type="", session_id=""):
		self.timestamp = timestamp
		self.type = event_type
		self.session_id = session_id

	def init_from_dict(self, event_dict):
		self.timestamp = event_dict.get("timestamp")
		self.type = event_dict.get("event_type")
		self.session_id = event_dict.get("session_id")		

	def show_description(self):
		print("This is generic event.")

calss ItemViewEvent(Event):
	type = "itemViewEvent"

	def _init_(self, timestap=0, session_id="", numder_fo_views=0):
		self.timestamp = timestamp
		self.session_id = session_id		
		self.namder_of_views = namber_of_views

	def show_description(self):
		print("This event means someone has browsed an item.")

if _name_ == "_main":
	test_view_event = ItemViewEvent(timestamp=1549461608000, session_id="0:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGLLpmct", namder_of_views=6)
	test_view_event.show_description()
	print(test_view_event.type)

# Вывод:
# This event means someone has browsed an item.
# itemViewEvent	

# Что получили:

# 1. Переопределили конструктор класса. Теперь мы используем не 
#    родительский, а свой, и передаём в него другой набор аргументов. Так
#    у нас получился кастомизированный набор атрибутов: у родительского 
#    класса нет атрибута number_of_views.

# 2. Переопределили значение атрибута type с помощью атрибута класса. 
#    Теперь при вызове type от экземпляра нашего дочернего класса мы
#    получим значение атрибутов type от нашего класса ItemViewEvent.

# 3. Переопределили работу метода show_descripton: теперь он
#    показывает более специфическое для класса описание.

# Проверка типа объекта

# В некотором смысле, определяя новый класс. вы создаёте новый тип
# данных. Базовые типы данных, передоставляяемые Python, так же евляются
# классами - иначе откуда у них методыю :-)

# Давайте убедимся в этом с помощью ыункции isinstance.

# Всё просто: вы передаёте в неё объект и тип (класс), а функция возвращает
# логическое значение результата проверки. То есть говорит вам, является
# ли объектом нужного вам типа (класс).

>>> print(isinstance("foo",str))
True
>> print(isinstance(test_view_event, ItemViewEvent))
True

# Но у этого метода есть загвоздка:

>>> print(isinstance(test_view_event, Event))
True

# Мы видим, что для родительского класса функция также вернёт True. На 
# самом деле, по этой и ряду других причин не всегда хорошо завязывать
# логику на проверку типа через isinstance.

# Мы уже говорили о том, что в некотором смысле в Python всё - объект. Эот
# охначает, что "под капотом" все классы и типы в Python наследуются от object.

>>> print(isinstance("foo",str))
True

# О болле сложном наследовании

# Классы в Python поддерживают наследование6 это значит,
# что при объявлениии класса вы можете через запятую в качестве
# нескольких аргументов перечислить несколько классов. При этом порядок 
# перечесления важе, так как от этого будет зависить, в каком порядке
# Python будет искать одноименные атрибуты и методы, определяя, какой
# буде кем переопредёлен.

# Рассмотрим множественное наследование на примере отдельных и
# квартиры.

# Создадим файл flat.py с родительскии для двух комнат и кухни:

class Room1:
	def get_room(self):
		print('room1')

class Room2:
	def get_room(self):
		print('room')

	def get_room2(self):
		print('room2 for flat')

class Kitchen:
	def git_kitchen(self):
		print("kitchen")

class Flat(Kitchen,Room1,Room2):
	...

f=Flat()
f.get_kitchen()
f.get_romm()
f.get_room2()

# Класс Flat наследует классы отдельных комнат в следующем порядке:
# Kitchen, Room1, Rppm2. Это значит, что поиск методов при их вызове
# (f.get_kitchen() и др.) сначала будет осуществляться в классе kitchen, 
# затем, если метод не найден, в классе Room1, и только затем Room2. Это 
# хорошо видно на примере вызова метода get_room().

# Также заметим, что наследуемый класс Flat также будет определяться,
# как Kitchen, Room1, Room2 в функции isinstance:

print(isinstance(f,Kitchen))
print(isinstance(f,Room1))
print(isinstance(f,Room2))

# В более сложных случаях наследования, например, когда несколько
# родительских классов сами имеют родительский класс, порядок
# использования методов определяется специальными алгоритмами поиска
# (вы будете знакомиться с алгоритмами в модуле С4).

# Рассмотрим нбольшой пример:

class Room: 
	def get_room(self):
		print('room')

class Room1(Room): 
	def get_room(self):
		print('room1')
class Room2(Room): 
	def get_room(self):
		print('room2')

class Flat(Room1,Room2):
	...

print(Flat.mro()) # метод класса, который показывает порядок наследования

f=Flat()
f.get_room()

# Обратите внимание на метод mro(), он относится к методам класса, а не
# объекта класса, поэтому вызывается непомредственно от Falt.
# Метод mro() возвращяет порядок, в котором будет проинспектированы 
# родительские классы. Методы класса будцт подробно расмотрены в 
# следующим модуле.

# На практике сложные системы наследования используются не так уж часто.
# Как правило, бурются сторонние готовые библиотеки и модули 
# и выполняется наследование от нужных классов, чтобы дополнить и 
# переопределить их логику.
 
