# C1.5. Магический метод _init_

# Мы уже говорили о том, что классы задают структуру данный своих 
# будущих экземпляров с помощью атрибутов. Но если у лубого эземпляра 
# можно задавать произвольные атрибуты, а затем совершенно независимо
# менять, то как это поможет нам создовать кучу одинаковых обьектов 
# и управлять их единообразием?

# Для этого используется конструктора класса, магический метод _init_ 
# который зарание определяеться атрибуты новых экземпляров. 
# Первым атрибутом он обезательно принимает на вход self, 
# а дальше - произвольный набор аргументов, как обычная функция:

class User: 
	def _init_(self, name, email):
		self.name = name
		self	.email = email
		
# Здесь _init_ - это так называемый "магический" метод-конструктур,
# окруженный двумя нижними подчёркиваниями с обеих сторон. Такие
# подчёркивания иногда для кратности называют дандерами, от 
# "dauble underscore". Магические методы обычно неявно вызываются при
# совершении каких-либо операций, и мы подробнее разберём их дальше 
# в курсе. Пока что для нас неважно, почему он называеться именно так -
# достаточно запомнить, что конструктор класса всегда называеться 
# именно _init_.

# Метод-конструктор задаётся как функция внутри класса (не забудьте про
# отступ) и первым аргументом всегда принимает self. Именно спомощью
# этого хитрого финта в него передаёться объект с экземпляром, поэтому
# его нельзя забывать. 

# Этот метод вызывается каждый раз, когда мы создаём экземпляр.

# После того, как мы задали конструктор, при создании объекта в скобки 
# вызова класса можно передавать аргументы, которые он принимает на 
# вход. Чтобы не запутаться, можно явно указать, в какой аргумент что 
# класть:

peter = User(name="Peter Robertson",
email ="peterrobertson@mail.com")
julia = User(name="Julia Donaldson",
email ="juliadonaldson@mail.com")

print(peter.name)
print(julia.email)
# Выыод:
# Peter Robertson
# juliadonaldson@mail.com

# Вроде бы выглядит похоже на то, что мы получили в прошлый раз, но есть
# ключевая разница: при создании экземпляра класса мы сразу же задаём
# содержимое его атрибутов. Если так не сделать и не передать в вызов
# класса нужные аргументы, мо получим ошибку:

>>> chis = User()

# Выыод:
# TypeError: _init_() missing 2 required positional 
# arguments: 'name' and 'email'

# Мы видим, что конструктор класса способен задавать строгую структуру 
# для создаваемых экземпляров - уже одно это способно помочь с 
# обеспечением единообразия большого количества однотипных обьектов.
# У каждого, как минимум, будет одинаковый набор атрибутов.

# 1.5.1 + +
# Выберите правильные утверждения (множественный выбор).
# 
# Без разницы, как называть метод-конструктор. Главное, чтобы он
# был определён внутри класса и принимал на вход self.
# 
# Аргумент self можнт идти любым по порядку, главное, чтобы он
# назывался self.
# 
# Чтобы задать атрибут для обьектов класса в конструкторе, нужно 
# просто принимать название и приписать его после sels - 
# self.attr_name = "value". Больше ничего не требуется. +++
# 
# Атрибуты, заданные в методе _init_ , будут доступны у всех обьектов
# класса. +++

# 1.5.2
# 
# Какое утверждение верно?
# 
# Если окружить переменную двойными подчёркиваниями с обеих 
# сторон, она станет приватной.
# 
# Приватные переменные нельзя импортировать.
# 
# Название переменной может представлять из себя просто 
# одинарный знак подчёркивания. + + + 
# 
# Метод, который работает с экземпляром класса, называеться магическим.

5
