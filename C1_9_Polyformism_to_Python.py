# C1.9. Полиморфизм  в Python

# Как использовать полиморфизм пр создании классов.

# Полиморфизм в ООП обрабатывает разные типы данных, принадлежащих
# к различным классам, с помощью одной и той же функции (метода). По сути
# одинаковым являеться только имя метода, но результаты работы
# одноимёрнных методов могут различаться.

# Рассмотрим пример

# В файле rectangle.py нам необходимо рассчитать площадь геометрической
# фигуры на основание полиморфизма:

class Rectangle:
	def _init_(self, a, b)
		self.a = a
		self.b = b
	def get_area(self):
		return self.a * self.b

# Как оргпнизовать работу

# Откройте PyCharm  и выполните параллельно все действия, в том числе
# впишите код со скриншотов. Следите за ходом рассуждений.

# Итак, у нас есть класс Rectangle с двумя параметрами: ширина и высота
# (а и b). Мы можем найти площядь прямоугольника. Для этоно нужно длину
# умножить на высоту (строка кода 6). Для решения используем специальный
# метод get_area. Он принимает аргумент self, то есть сам класс
# Rectangle и возвращает произведение атрибута а (ширина) и  b (высота).

# Создадин файл rectangle_2.py в отдельной деректории в папке (назовём её
# python_practice). Выполним импорт класс Rectangle:

from rectangle import Rectangle

# Что мы видим в файле rectangle_2.py:

from rectangle import Rectangle

# Далее создаём два прямоугольника

rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,5)
# Вывод площади наших двух прямоугольников
print(rect_1.get_area())
print(rect_2.get_area())

# Запустим наш исходный код, чтобы получить результат вычисления
# площади уже двух прямоугольников.

# Добавим в нашу прогграмму ещё один объект, например Square (квадрат),
# которой принимает в качестве аргументов одну сторону. Добавляем
# данные в исходном файле rectangle.py

class Rectangle:
	def _init_(self, a, b)
		self.a = a
		self.b = b
	def get_area(self):
		return self.a * self.b

class Square:
	def _init_(self, a)
		self.a = a
	def get_area_square(self):
		return self.a ** 2
# Возведение в степень **2 (в квадрат)

# Переходим в файл 	rectangle_2.py и импортируем наш новый объект:

from rectangle import Rectangle, Square

# Далее создаём два прямоуголника

rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,5)
# Вывод площади наших двух прямоугольников
print(rect_1.get_area())
print(rect_2.get_area())

square_1 = Square(5)
square_2 = Square(10)

print(square_1.get_area_square(),
	   square_2.get_area_square())

# Запустим программу и посмотрите ожидаемый результат в консоли:
# площадь прямоугольника и квадрата. Можно более лаконично выводить
# два квадрата: через запятую (см. 14 строчку).

# Теперь мы хотим в нашей программе все обьекты перенести в единную
# коллекцию. Назовём фигуры (figures). Колекция содержит список, в
# который и помещаем наш первый прямоугольник, квадрат и т.д.(см. 17
# строчку). Работаем в файле rectangle_2.py:

from rectangle import Rectangle, Square

# Далее создаём два прямоуголника

rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,5)
# Вывод площади наших двух прямоугольников
print(rect_1.get_area())
print(rect_2.get_area())

square_1 = Square(5)
square_2 = Square(10)

print(square_1.get_area_square(),
	   square_2.get_area_square())

figures = [rect_1, rect_2, square_1, square_2]

# Далее пройдём по циклю for:

print(square_1.get_area_square(),
	   square_2.get_area_square())

figures = [rect_1, rect_2, square_1, square_2]
for figures in figures:
	if isinstance (figures, Square):
		print(figures.get_area_square())
	else:
		print(figures.get_area())

# Мы обходим наши фигуры по циклю, чтобы для каждой фигуры найти
# площадь. Обратите внимание, мы будем рвботать с прямоугольниками и
# квадратами с помощью различных методов: (get_area() и get_area_square()).

# Внутри цикла проверяем:
#
# 	* если экземпляр класса figures являеться квадратом, то вызываеться метод
# 	   get_area_square()).
#
# 	* в противном случае, мы обрабатываем данные для прямоугольника
# 	   методом get_area().

# В условии если функция isinstance, поддерживающая наследование. 
# Функции возвращает True, если первый аргумент функции являеться
# экзкмпляром класса, где класс задаётся вторым разных аргументом. Иными
# словами, функция проверяет, принадлежин ли объект к классу.

# Определение полиморфизма могут несколько отличаться в различных
# источниках. В общем виде определение такое:

# Полиморфизм в коде - это когда определённая часть кода (чаще 
# всего функция) может обрабатывать объекты различных классов, меняя
# поведение в зависимости от класса.

# Тут код в теле цикла меняет поведение в зависимости от класса figure.
# Если выделить код из тела цикл в отдельную функцию, то код будет
# соответствовать более распространённому определению. Согласны, что 
# проработка одноимённых методов внутри отдельных классов будет более
# показательным примером полиморфизма. 

# Перегрузка операторов - явный указатель на полиморфизм. А в Python для
# этого предусмотрины специальные магические методы вроде __eq__.

# Ещё немного о полиморфизме и магических методах 
# на примере __eq__ и __str__.

# Давайте рассмотрим ещё один полезный пример полиморфизма в классах
# Python - перегрузку операторов и методов.

# Возмём несколько наиболее часто используемых методов:
# 
# 	* __eq__ - определяет поведение оператора равенства ==;
# 
# 	* __str__ - определяет поведене функции str() или вызов внутри 
# 				функции print().

# А теперь рассмотрим пример.

# Создадим файл points.py. Внутри файла определим класс Dot, который будет
# хранить в себе информацию о точках на плоскости в системе координат 
# х, у:

class Dot:
	def __init__(self, x, y):
		self.x = x
		self.y = y 
		
# Нам необходимо уметь срвнивать точки между собой и выводить их для 
# пользователя. Соответсвенно переопределим
# метод __eq__ и __str__ внутри класса Dot.

def __eq__(self, other ):
	return self.x ==  other.x and self.y ==  other.y
	
def __str__(self):
	return f'Dot: {self.x, self.y}'
	
# Теперь давайте посмотрим на поведение экземпляров классв:

p1 = Dot(1,2) 
p2 = Dot(1,2)
print(p1 == p2)
print(str(p1))
print(p2)

# В выводе видим: 
# True
# Dot: (1, 2)
# Dot: (1, 2)

# В первой строчке видим, что точки успешно сравниваються между собой. Во
# второй и третий строчке выводится информация об экземплярах класса.
# Обратите внимание, что перегруженный метод str, автоматически
# используется в функции print, поэтому писать его не обезательно.

# 1.9.1
# Выполните задание, взяв за основу код из примера выше.
 
# Давьте ещё один класс - круг (class Circle), конструктор которого
# содержит параметр радиус. Добавьте метод для расчёта площади круга
 
# Далее сделайте вывод информации о площади в консоль.

class Rectangle:
	def __init__(self, a, b):
		self.a = a
		self.b = b	
	def get_area(self):
		 return self.a * self.b

class Square:
	def __init__(self, a):
		self.a = a
	def get_area_square(self):
		return aelf.a ** 2  
				 
class Circle:
	def __init__(self, a):
		self.a = a
	def get_area_circle(self):
		return (self.a ** 2) * 3.14
		
rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,5)
square_1 = Square(5)
square_2 = Square(10)
circle_1 = Circle(1)
circle_2 = Circle(2)

figeres = [rect_1, rect_2, square_1, square_2, circle_1, circle_2]
for figere in figeres:
	if isinstance(figere, Square):
		print(figere.get_area_square())
	elif isinstance(figere, Rectangle):
		print(figere.get_area())
	else:
		print(figere.get_area_circle())
		
# 1.9.2
# Добавте класс Rectangle перегрузку оператора == и сравните 
# несклько экземпляолв одного класса.

class Rectangle:
	def __init__(self, a, b):
		self.a = a
		self.b = b
	def get_area(self):
		return self.a == other.a and self.b == other.b
		
rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,4)

print(rect_1 == rect_2)

